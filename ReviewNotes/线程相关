1. 主队列的任务一定在主线程中执行
2. 主线程不一定在主队列中执行

3. 同步: 不具备开启线程的能力, 一定串行执行任务
4. 异步: 具有开启线程的能力, 但在主队列中不会开启新的线程, 
	如果再串行队列和并发队列里开启n个子线程, gcd优化后未必真的有n个子线程

5. 并行: 同一时刻 多个指令在多个处理器上一起执行
   并发: 在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行
   串行: 一个执行完执行另一个

   同步执行+并发队列: 不会开启线程, 执行完任务再执行下一个
   异步执行+并发队列: 会开启线程, 并发执行
   同步执行+串行队列: 不会开启线程, 执行完任务再执行下一个
   异步执行+串行队列: 会开启线程,  执行完任务再执行下一个
   同步执行+主队列:   不会创建线程, 执行完任务再执行下一个
   					主线程执行会卡死,  非主线程执行,
   异步执行+主队列:   在主线程中执行, 执行完任务再执行下一个

   

保证主队列中执行 sdweb 判断主队列label是不是等于当前队列

	3、为什么只在主线程刷新UI？

		UIKit并不是一个 线程安全的类，UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。
      另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。
      而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上同时更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。

	4.如何使线程保活
		1.加个mach_port
		2.runloop run 永不停止
		3.加个timer
		4. 