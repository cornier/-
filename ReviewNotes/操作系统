操作系统


静态库
	相似段合并
	1.连接器能获得所有的输入目标文件的端长度, 将他们合并, 计算出输出文件总各个端合并后的长度和位置, 建立映射关系
	2.根据上面收集的所有信息, 读取输入文件中段的数据, 重定位信息, 并且进行复核解析与重定位, 调整代码中的地址
		给了函数临时的假地址,
		链接器在完成地址和空间分配之后偶就可以确定所有符号的虚拟地址, 
		那么链接器就可以根据符号的地址对每个需要重定位的指定进行地址修正,
		重定位表的数据专门用来保存这些与重定位相关的信息

动态库:
	动态链接器自举, (操作系统将进程控制权交给动态链接器, 动态链接器的子举代码即开始执行, 子举代码不可以使用全局变量和静态变量之外, 甚至不能调用函数, 即动态链接器本身的函数也不能调用)
	完成子举以后,动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表中, 我们称它为全局符号表




	ios 没有内存交换机制
	内存管理 MMU
	首先会在 TLB（Translation Lookaside Buffer）中进行查询，它表位于 CPU 内部，查询速度最快；
	如果没有命中，那么接下来会在页表（Page Table）中进行查询，页表位于物理内存中，所以查询速度较慢；
	最后如果发现目标页并不在物理内存中，称为缺页，此时会去磁盘中找。当然，如果页表中还找不到，那就是出错了

	在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。???   ios  16k?  ios 10之后 32k
	当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡
	

线程和进程的关系?
	一个程序至少有一个线程, 一个进程可以有多个线程
	进程: 有独立的内存单元, 多个线程共享一快内存
	线程: 指进程内的一个执行单元, 是线程的基本组成单位
	区别: 
		1.调度: 线程作为调度和分配的基本单位
				线程作为拥有资源的基本单位
		2.并发性:不仅进程之间可以并发执行, 同一个进程的多个线程也可以并发执行
		3.拥有资源: 进程是拥有系统资源(单独的地址空间), 线程不拥有系统资源, 但可以访问隶属于进程的资源
		4. 系统开销: 创建或撤销进程时, 系统都要分配和回收资源,导致系统的开销明显大于创建或者撤销线程时的开销, 一个线程崩溃导致进程崩溃, 如果是主线程会导致程序崩溃, 多进程中子进程奔溃了不会影响到其他进程
		
		Em..:
		进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

进程间通信: https://mp.weixin.qq.com/s/TZJ0N8iDjU3dEoU6W1GctQ
	管道:
		匿名管道(|) 用完就销毁
		命名管道  文件类型是p

		创建一个匿名管道, 返回两个操作符, 一个读取端描述符fd[0], 一个写入端描述符fd[1], 创建一个特殊的文件, 只存在内存, 所谓的管道就是内核里面的一串缓存, 从一段写 其实是缓存在内核中, 另一端读 是从内核中读取这段数据, 并且管道传输的数据是无格式的流且大小受限

		对于匿名管道, 通信范围是存在父子关系的进程
		对于明明管道, 他可以再不相关的进程中也能相互通信
		通信数据都遵守先进先出的原则

	消息队列
		消息队列是保存在内核中的消息链表
		通信不及时, 附件也有大小限制
		因为再内核中每个消息体都有一个最大长度的限制, 同时所有队列所包含的全部消息体的总长度也是有上限的

		在Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度

		消息队列通信过程中, 存在用户态与内核态之间的数据拷贝开销

	共享内存
		共享内存的机制, 就是拿出一块虚拟地址空间来, 映射到相同的物理内存中
	信号量 
		为了防止多进程竞争共享资源, 使得共享的资源在任意时刻只能被一个进程访问

		信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据

		p: 信号量减一, 如果<0 阻塞等待, >=0 进程正常执行
		v: 信号量加一, 如果<= 0 唤醒阻塞中的进程运行, > 0 表示没有阻塞进程
	信号
		信号是进程间通信机制中唯一的异步通信机制,
		可以再任何时候发送信号给某一个进程, 用户进程对信号的操作方式, 1.执行默认操作, 2.捕捉信号, 3.忽略信号, 除了SIGKILL和SEGSTOP不能捕捉和忽略
	socket
		实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；
		实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；
		实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；










